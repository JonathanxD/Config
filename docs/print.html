<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Config Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="backend.html"><strong aria-hidden="true">1.1.</strong> Backends</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">1.2.</strong> Config class</a></li><li class="chapter-item expanded "><a href="key_and_keyspec.html"><strong aria-hidden="true">1.3.</strong> Key and KeySpace</a></li><li class="chapter-item expanded "><a href="serializers.html"><strong aria-hidden="true">1.4.</strong> Serializers</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.5.</strong> Getting Started</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Config Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="text-align:center">
<p><img src="logo.png" alt="LOGO" /></p>
<p><img src="https://img.shields.io/github/v/tag/JonathanxD/Config?sort=semver" alt="Version" /> <img src="https://img.shields.io/jitpack/v/github/JonathanxD/Config" alt="Jitpack" /></p>
</div>
<p>Config is an agnostic key-based configuration library, built on top of the concept of holding reference to a value in the configuration instead of holding the value itself.</p>
<h1 id="map-oriented"><a class="header" href="#map-oriented">Map oriented</a></h1>
<p>The library is totally map-oriented, it stores and reads values from <code>Map</code>s, also even if there is a concept of <code>Storage</code> classes, which is the medium of the data storage, and they could store data in any format, most of the common implementations uses Maps and all keys are String-only, this is intentional, and we focus only in storing data in <code>Map</code>s. </p>
<p>All values are serialized upfront before being stored, in other words, when they are sent to a <code>Storage</code> medium, they are already serialized using built-in and custom serializers. Any library capable of rendering <code>Map</code>s could take advantage of <code>Config</code>.</p>
<h1 id="key-basedpointer-oriented"><a class="header" href="#key-basedpointer-oriented">Key based/Pointer oriented</a></h1>
<p>Config uses a pointer-oriented data access and write, this allows data changes to be reflected all across the application, and config-reloading could be simply implemented by using File Watchers.</p>
<h1 id="agnostic"><a class="header" href="#agnostic">Agnostic</a></h1>
<p>Config does not care about the final format of the configuration file, it only manages data in a <code>Map</code>. The class responsible for loading and saving this <code>Map</code> in the configuration is the <code>Backend</code> class. It also provides which types are supported to be stored in the <code>Map</code> without the serialization and deserialization process.</p>
<p>We provide common backend implementations for most used configuration languages, such as Json, Yaml, Toml and XML. Since all of those libraries are able to render <code>Maps</code> as Strings, they become very handful for application configuration.</p>
<h1 id="serialization-supported"><a class="header" href="#serialization-supported">Serialization supported</a></h1>
<p>Serialization of custom types are supported through <code>Serializers</code> registry and <code>Serializer</code> implementation, and it is very easy to implement your own serializer. Also, API provides interfaces for implementing serialization of complex types.</p>
<h1 id="type-information-retention"><a class="header" href="#type-information-retention">Type information retention</a></h1>
<p>Config depends on types provided by <code>TypeInfo</code> tokens for implementing Serialization for <code>Map</code>, <code>List</code> and user defined types.</p>
<p>This allows generic types to be serialized correctly and using the right serializer, instead of relying on the type of the object itself. This means that types must be explicitly provided, and the information must be retained at runtime.</p>
<h1 id="backend"><a class="header" href="#backend">Backend</a></h1>
<p>Config itself does not implement any configuration format, instead, it backs the configuration loading and saving logic to a backend.</p>
<p>Currently, the following backend implementations are officially supported:</p>
<ul>
<li>Config-Jackson (Using <a href="https://github.com/FasterXML/jackson">fasterxml.jackson</a>)</li>
<li>Config-XML (Using <a href="https://github.com/FasterXML/jackson-dataformat-xml">fasterxml.jackson-xml</a>)</li>
<li>Config-Json (Using <a href="https://github.com/fangyidong/json-simple">JSON.simple</a>)</li>
<li>Config-Yaml (Using <a href="https://bitbucket.org/asomov/snakeyaml/">snakeyaml</a> YAML 1.1 compliant)</li>
<li>Config-Yaml-1.2 (Using <a href="https://bitbucket.org/asomov/snakeyaml-engine/">snakeyaml-engine</a> YAML 1.2 compliant)</li>
<li>Config-Toml (Using <a href="https://github.com/tomlj/tomlj">tomlj</a> 1.0.0-rc.1 compliant. With an experimental renderer, as of the time the implementation was written, there is no official TOML writer for Java).</li>
</ul>
<p>You could choose one of these backends to load and save your configuration. Also, you are free to write your own Backend implementation, as they are very simple. Config works solely with Java <code>Map</code>, <code>List</code>, <code>String</code> and primitive types.</p>
<p>Also, Config is not a real-time configuration editor, it will not save the configuration for every update that occurs in the Config object, you need to manually save and load using <code>Config.save</code> and <code>Config.load</code>. If you need a real-time configuration editor with reload capabilities, you could easily write a File Watcher or Scheduler to reload configuration using those methods.</p>
<h2 id="toml-backend"><a class="header" href="#toml-backend">Toml Backend</a></h2>
<p>The Toml backend is able to read any TOML configuration file compliant to 1.0.0-rc.1, however, for writing Toml config, it uses an experimental renderer as there is no recent and maintained Toml library for Java which allows Toml rendering.</p>
<p>This means that Toml files saved by TOML backend ends up being different from the original, and is not rendered in the best way it could be following the Toml standards.</p>
<h2 id="yaml-12-backend"><a class="header" href="#yaml-12-backend">YAML 1.2 Backend</a></h2>
<p>There is a Yaml 1.2 backend which uses snakeyaml-engine to read and write yaml files, however, since <code>Config</code> is fully map-oriented, yaml files which does not have any keys, like this one:</p>
<pre><code class="language-yaml">- First
- Second
- Third
</code></pre>
<p>Are loaded normally, but an intermediate section is created, named <code>.</code>. This section allows loading those values normally, and rendering them is made through a special logic which keeps this structure (as long as there is no new keys defined).</p>
<p>Also, <code>Config</code> calls the <code>Backend</code> to resolve the root key, then the Yaml backend resolve the <code>.</code> as default key, thus allowing to load those values seamlessly without careing about the intermediate section:</p>
<pre><code class="language-java">public class ConfigLoader {
    public static Config loadYaml() {
        // Yaml loading logic...
        Config config = new Config(new YamlBackend(...));
        TypeInfo&lt;List&lt;String&gt;&gt; stringListTypeInfo = TypeInfo.builderOf(List.class).of(String.class).buildGeneric();
        Key&lt;List&lt;String&gt;&gt; values = config.getRootKey().getAs(stringListTypeInfo);
    }
}
</code></pre>
<p>It is important to know this, because creating a configuration with a key named <code>.</code> with a List value will trigger this behavior. But only for Yaml 1.2 backend.</p>
<h3 id="maps-inside-the-list"><a class="header" href="#maps-inside-the-list">Maps inside the List</a></h3>
<p>When there is a map inside the list, like this:</p>
<pre><code class="language-yaml">- First
- Second
- Third
- Somedata: value
</code></pre>
<p>Config will be able to handle this situation, but with limited capabilities. It is able to resolve the <code>somedata</code> key and change its value:</p>
<pre><code class="language-java">public class ConfigLoader {
    public static Config loadYaml() {
        // Yaml loading logic...
        Config config = new Config(new YamlBackend(...));
        Key&lt;List&lt;Object&gt;&gt; values = config.getRootKey().getAs(CommonTypes.LIST_OF_OBJECT);
        Key&lt;String&gt; somedata = values.getKey(&quot;somedata&quot;, String.class);
        somedata.setValue(&quot;newValue&quot;);
    }
}
</code></pre>
<p>It is able to create new maps inside the list when needed:</p>
<pre><code class="language-java">public class ConfigLoader {
    public static Config loadYaml() {
        // Yaml loading logic...
        Config config = new Config(new YamlBackend(...));
        Key&lt;List&lt;Object&gt;&gt; values = config.getRootKey().getAs(CommonTypes.LIST_OF_OBJECT);
        Key&lt;String&gt; somedata = values.getKey(&quot;somedata2&quot;, String.class); // new map is created to handle this key
        somedata.setValue(&quot;newValue2&quot;); 
    }
}
</code></pre>
<p>And access and change values in a specific index of a list (which must exists):</p>
<pre><code class="language-java">public class ConfigLoader {
    public static Config loadYaml() {
        // Yaml loading logic...
        Config config = new Config(new YamlBackend(...));
        Key&lt;List&lt;Object&gt;&gt; values = config.getRootKey().getAs(CommonTypes.LIST_OF_OBJECT);
        Key&lt;String&gt; index0 = IndexKey.forKeyAndIndex(values, 0);
        index0.setValue(&quot;newValue2&quot;); 
    }
}
</code></pre>
<p>However, not all features that Yaml 1.2 supports was tested.</p>
<h2 id="config"><a class="header" href="#config">Config</a></h2>
<p>Config is a fully map-based <code>Storage</code> implementation, it uses a <code>LinkedHashMap</code> as storage medium, while checks for supported value types using <code>Backend.supports</code>. Thus, every value stored in this class is directly stored in the wrapped <code>LinkedHashMap</code>, and when configuration need to be saved to file, it just sends an unmodifiable copy of this <code>map</code> to the <code>backend</code> (it must be a copy and unmodifiable to avoid concurrency issues).</p>
<p>Also, Config is not Thread-safe by default, this means that to concurrently write values, you need to implement a locking logic to allow only one modification at a time. We plan to provide a concurrent capable implementation in the future.</p>
<h1 id="key"><a class="header" href="#key">Key</a></h1>
<p>The most important class of the Config library. A <strong>Key</strong> represents a pointer to a value in the configuration file, tied to a <strong>key-path</strong>. With this pointer you are able to read and write values directly to the <code>Storage</code> medium without even needing to hold a reference to the <code>Storage</code> itself. Also, you could have different pointers to the same value, and changing a value through one pointer will be reflected in all other pointers (they are not really reflected, they just read the value from the same path, so if the value changes, anyone pointing to this path has access to the new value).</p>
<h1 id="keyspec"><a class="header" href="#keyspec">KeySpec</a></h1>
<p>Is a specification of a <code>Key</code> name and type, with <code>KeySpec</code> you refer to a part of the key path. It is used to implement a more readable <code>Key</code> access with constant path parts.</p>
<h1 id="serializers"><a class="header" href="#serializers">Serializers</a></h1>
<p>Config also supports serializers. This is very important for the library as it only works with <code>Maps</code>, <code>Lists</code>, <code>Strings</code> and primitive types (different backends could provide support for others types, but the official ones does not).</p>
<p>Serializers are registered and provided through <code>Serializers</code> class, custom serializers must implement <code>Serializer</code> interface and be registered in <code>Config.getSerializers</code>.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Config and official backends are available through <a href="https://jitpack.io/#JonathanxD/Config">jitpack.io</a>.</p>
<h3 id="gradle-kotlin"><a class="header" href="#gradle-kotlin">Gradle (Kotlin)</a></h3>
<pre><code class="language-kotlin">val config_version by project

repositories {
    mavenCentral()
    maven(&quot;https://jitpack.io&quot;)
}

dependencies {
    implementation(&quot;com.github.JonathanxD.Config:Config:$config_version&quot;)
    implementation(&quot;com.github.JonathanxD.Config:Config-Toml:$config_version&quot;) // Toml backend
}
</code></pre>
<h2 id="reading-and-writing-values"><a class="header" href="#reading-and-writing-values">Reading and writing values</a></h2>
<p>Given the following Toml config:</p>
<pre><code class="language-toml">[server]
addr = &quot;0.0.0.0&quot;
port = 8080
</code></pre>
<p>You could write something like this to read and write values:</p>
<pre><code class="language-java">public class ServerConfig {
    private final Config config;
    private final Key&lt;String&gt; addr;
    private final Key&lt;Long&gt; port;
    
    public ServerConfig(Path configPath) {
        ConfigIO io = ConfigIO.path(configPath, StandardCharsets.UTF_8);
        Backend backend = new TomlBackend(io);
        this.config = new Config(backend);
        this.config.load(); // Config file must exists
        
        Key&lt;Void&gt; serverSection = this.config.getRootKey().getKeySection(&quot;server&quot;); 
        this.addr = serverSection.getKey(&quot;addr&quot;, CommonTypes.STRING);
        this.port = serverSection.getKey(&quot;port&quot;, CommonTypes.LONG);
    }
    
    public String getAddress() {
        return this.addr.getValue();
    }
    
    public long getPort() {
        return this.port.getValue();
    }
    
    public void setPort(long port) {
        this.port.setValue(port);
    }
    
    public void save() {
        this.config.save();
    }
}
</code></pre>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Config already implements serializers for basic types and date types, and some JwIUtils library types, such as <code>Text</code> and <code>TypeInfo</code> (you could find all <a href="https://github.com/JonathanxD/Config/blob/master/src/main/java/com/github/jonathanxd/config/serializer/Serializers.java">here</a>), however, sometimes you want to work with your custom types (or 3rd party types) which does not have default serializers implemented, for this, Config provides <code>Serializers</code> class as registry base for <code>Serializer</code> implementations.</p>
<h3 id="basic-serializer"><a class="header" href="#basic-serializer">Basic Serializer</a></h3>
<pre><code class="language-java">record User(String name, String email) {
    
}

public class UserSerializer implements Serializer&lt;User&gt; {
    @Override
    public void serialize(User value,
                          Key&lt;User&gt; key,
                          TypeInfo&lt;?&gt; typeInfo,
                          Storage storage,
                          Serializers serializers) {
        key.getKey(&quot;name&quot;, String.class).setValue(value.name());
        key.getKey(&quot;email&quot;, String.class).setValue(value.email());
    }

    @Override
    public User deserialize(Key&lt;User&gt; key,
                              TypeInfo&lt;?&gt; typeInfo,
                              Storage storage,
                              Serializers serializers) {

        String name = key.getKey(&quot;name&quot;, String.class).getValue();
        String email = key.getKey(&quot;email&quot;, String.class).getValue();

        return new User(name, email);
    }
}
</code></pre>
<p>Also, sometimes you just want to store a single value, for this you could use <code>Key.getAs</code> to transform the Key type:</p>
<pre><code class="language-java">record User(String name) {
    
}

public class UserSerializer implements Serializer&lt;User&gt; {
    @Override
    public void serialize(User value,
                          Key&lt;User&gt; key,
                          TypeInfo&lt;?&gt; typeInfo,
                          Storage storage,
                          Serializers serializers) {
        key.getAs(String.class).setValue(value.name());
    }

    @Override
    public User deserialize(Key&lt;User&gt; key,
                              TypeInfo&lt;?&gt; typeInfo,
                              Storage storage,
                              Serializers serializers) {

        return new User(key.getAs(String.class).getValue());
    }
}
</code></pre>
<h3 id="calling-other-serializers"><a class="header" href="#calling-other-serializers">Calling other serializers</a></h3>
<p>Config automatically invoke other serializers to proceed with the serialization when a value is not supported by the backend, so the code below will work correctly and serialize the <code>LocalDate</code> as well.</p>
<pre><code class="language-java">record User(LocalDate registrationDate, String name) {
    
}

public class UserSerializer implements Serializer&lt;User&gt; {
    @Override
    public void serialize(User value,
                          Key&lt;User&gt; key,
                          TypeInfo&lt;?&gt; typeInfo,
                          Storage storage,
                          Serializers serializers) {
        key.getKey(&quot;registrationDate&quot;, LocalDate.class).setValue(value.email());
        key.getKey(&quot;name&quot;, String.class).setValue(value.name());
    }

    @Override
    public User deserialize(Key&lt;User&gt; key,
                            TypeInfo&lt;?&gt; typeInfo,
                            Storage storage,
                            Serializers serializers) {

        LocalDate registrationDate = key.getKey(&quot;registrationDate&quot;, LocalDate.class).getValue();
        String name = key.getKey(&quot;name&quot;, String.class).getValue();

        return new User(registrationDate, name);
    }
}
</code></pre>
<p>However, when working with complex types which need an intermediate storage, this is not enough. For these cases, you could use the <code>Serializers</code> provided to <code>serialize</code> and <code>deserialize</code> methods. See below a hardcore version of <code>serialize</code> which does the same thing as the version above, however using intermediate storage:</p>
<pre><code class="language-java">record User(LocalDate registrationDate, String name) {

}

public class UserSerializer implements Serializer&lt;User&gt; {
    
    @Override
    public void serialize(User value, Key&lt;User&gt; key, TypeInfo&lt;?&gt; typeInfo, Storage storage, Serializers serializers) {
        Map&lt;Object, Object&gt; newMap = new LinkedHashMap&lt;&gt;();
        Map&lt;String, Object&gt; temp = new LinkedHashMap&lt;&gt;();

        Storage newStorage = Storage.createMapStorage(key, temp);

        {
            Key&lt;LocalDate&gt; regDateKey = key.getAs(&quot;registrationDate&quot;, LocalDate.class, newStorage);
            Object date = serializers.serializeUncheckedAndGet(value.getRegistrationDate(), regDateKey);
            temp.clear();
            newMap.put(&quot;registrationDate&quot;, date);
        }

        {
            Key&lt;String&gt; nameKey = key.getAs(&quot;name&quot;, String.class, newStorage);
            Object name = serializers.serializeUncheckedAndGet(value.getName(), nameKey);
            temp.clear();
            newMap.put(&quot;name&quot;, name);
        }

        storage.pushValue(key, newMap);
    }

    @Override
    public User deserialize(Key&lt;User&gt; key,
                            TypeInfo&lt;?&gt; typeInfo,
                            Storage storage,
                            Serializers serializers) {

        LocalDate registrationDate = key.getKey(&quot;registrationDate&quot;, LocalDate.class).getValue();
        String name = key.getKey(&quot;name&quot;, String.class).getValue();

        return new User(registrationDate, name);
    }
}
</code></pre>
<p>This approach is used by <code>ListSerializer</code> and <code>MapSerializer</code> to correctly serialize values in a controlled <code>Storage</code> medium. When you call <code>serializers.serialize*</code> with this intermediate storage, instead of serializing the value inside the <code>Storage</code> provided to <code>serialize</code> method, it does by serializing the value inside the provided <code>Storage</code> medium, thus serializing the value inside a controlled context, which will not overwrite or modify the values already stored.</p>
<p>With this, introspecting the values and changing the structure of them is more safe, as it will not damage the main storage medium (commonly the <code>Config</code> storage), and at in the end of serialization process, you can push to the main storage only the values you care about.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
